{
    "Node objects": {
        "content": "Node objects",
        "slug": "node-objects",
        "lvl": 1,
        "i": 0,
        "seen": 0,
        "parents": [],
        "chunk": " Node objects\n\nAST nodes are represented as `Node` objects, which may have any prototype inheritance but which implement the following interface:\n\n```js\ninterface Node {\n  type: string;\n  loc: SourceLocation | null;\n}\n```\n\nThe `type` field is a string representing the AST variant type. Each subtype of `Node` is documented below with the specific string of its `type` field. You can use this field to determine which interface a node implements.\n\nThe `loc` field represents the source location information of the node. If the node contains no information about the source location, the field is `null`; otherwise it is an object consisting of a start position (the position of the first character of the parsed source region) and an end position (the position of the first character after the parsed source region):\n\n```js\ninterface SourceLocation {\n  source: string | null;\n  start: Position;\n  end: Position;\n}\n```\n\nEach `Position` object consists of a `line` number (1-indexed) and a `column` number (0-indexed):\n\n```js\ninterface Position {\n  line: number; // >= 1\n  column: number; // >= 0\n}\n```\n"
    },
    "Changes": {
        "content": "Changes",
        "slug": "changes",
        "lvl": 1,
        "i": 1,
        "seen": 0,
        "parents": [],
        "chunk": " Changes\n"
    },
    "@babel/parser (Babylon) v7": {
        "content": "@babel/parser (Babylon) v7",
        "slug": "babelparser-babylon-v7",
        "lvl": 3,
        "i": 2,
        "seen": 0,
        "parents": [
            1,
            1
        ],
        "chunk": "## @babel/parser (Babylon) v7\n\nFlow: Node renamed from `ExistentialTypeParam` to `ExistsTypeAnnotation` [#322](https://github.com/babel/babylon/pull/322)\n\nFlow: Node renamed from `NumericLiteralTypeAnnotation` to `NumberLiteralTypeAnnotation` [babel/babylon#332](https://github.com/babel/babylon/pull/332)\n\nFlow: Node `Variance` which replaces the string value of the `variance` field on several nodes [babel/babylon#333](https://github.com/babel/babylon/pull/333)\n\nFlow: `ObjectTypeIndexer` location info matches Flow's better [babel/babylon#228](https://github.com/babel/babylon/pull/228)\n\nNode `ForAwaitStatement` has been removed [#349](https://github.com/babel/babylon/pull/349) in favor of modifying `ForOfStatement`\n\n`RestProperty` and `SpreadProperty` have been dropped in favor of `RestElement` and `SpreadElement`.\n"
    },
    "Identifier": {
        "content": "Identifier",
        "slug": "identifier",
        "lvl": 1,
        "i": 3,
        "seen": 0,
        "parents": [],
        "chunk": " Identifier\n\n```js\ninterface Identifier <: Expression, Pattern {\n  type: \"Identifier\";\n  name: string;\n}\n```\n\nAn identifier. Note that an identifier may be an expression or a destructuring pattern.\n"
    },
    "PrivateName": {
        "content": "PrivateName",
        "slug": "privatename",
        "lvl": 1,
        "i": 4,
        "seen": 0,
        "parents": [],
        "chunk": " PrivateName\n\n```js\ninterface PrivateName <: Node {\n  type: \"PrivateName\";\n  id: Identifier;\n}\n```\n\nA Private Name Identifier.\n"
    },
    "Literals": {
        "content": "Literals",
        "slug": "literals",
        "lvl": 1,
        "i": 5,
        "seen": 0,
        "parents": [],
        "chunk": " Literals\n\n```js\ninterface Literal <: Expression { }\n```\n\nA literal token. May or may not represent an expression.\n"
    },
    "RegExpLiteral": {
        "content": "RegExpLiteral",
        "slug": "regexpliteral",
        "lvl": 2,
        "i": 6,
        "seen": 0,
        "parents": [
            5
        ],
        "chunk": "# RegExpLiteral\n\n```js\ninterface RegExpLiteral <: Literal {\n  type: \"RegExpLiteral\";\n  pattern: string;\n  flags: string;\n}\n```\n"
    },
    "NullLiteral": {
        "content": "NullLiteral",
        "slug": "nullliteral",
        "lvl": 2,
        "i": 7,
        "seen": 0,
        "parents": [
            5
        ],
        "chunk": "# NullLiteral\n\n```js\ninterface NullLiteral <: Literal {\n  type: \"NullLiteral\";\n}\n```\n"
    },
    "StringLiteral": {
        "content": "StringLiteral",
        "slug": "stringliteral",
        "lvl": 2,
        "i": 8,
        "seen": 0,
        "parents": [
            5
        ],
        "chunk": "# StringLiteral\n\n```js\ninterface StringLiteral <: Literal {\n  type: \"StringLiteral\";\n  value: string;\n}\n```\n"
    },
    "BooleanLiteral": {
        "content": "BooleanLiteral",
        "slug": "booleanliteral",
        "lvl": 2,
        "i": 9,
        "seen": 0,
        "parents": [
            5
        ],
        "chunk": "# BooleanLiteral\n\n```js\ninterface BooleanLiteral <: Literal {\n  type: \"BooleanLiteral\";\n  value: boolean;\n}\n```\n"
    },
    "NumericLiteral": {
        "content": "NumericLiteral",
        "slug": "numericliteral",
        "lvl": 2,
        "i": 10,
        "seen": 0,
        "parents": [
            5
        ],
        "chunk": "# NumericLiteral\n\n```js\ninterface NumericLiteral <: Literal {\n  type: \"NumericLiteral\";\n  value: number;\n}\n```\n"
    },
    "BigIntLiteral": {
        "content": "BigIntLiteral",
        "slug": "bigintliteral",
        "lvl": 2,
        "i": 11,
        "seen": 0,
        "parents": [
            5
        ],
        "chunk": "# BigIntLiteral\n\n```js\ninterface BigIntLiteral <: Literal {\n  type: \"BigIntLiteral\";\n  value: string;\n}\n```\n\nThe `value` property is the string representation of the `BigInt` value. It doesn't include the suffix `n`.\n"
    },
    "Programs": {
        "content": "Programs",
        "slug": "programs",
        "lvl": 1,
        "i": 12,
        "seen": 0,
        "parents": [],
        "chunk": " Programs\n\n```js\ninterface Program <: Node {\n  type: \"Program\";\n  interpreter: InterpreterDirective | null;\n  sourceType: \"script\" | \"module\";\n  body: [ Statement | ModuleDeclaration ];\n  directives: [ Directive ];\n}\n```\n\nA complete program source tree.\n\nParsers must specify `sourceType` as `\"module\"` if the source has been parsed as an ES6 module. Otherwise, `sourceType` must be `\"script\"`.\n"
    },
    "Functions": {
        "content": "Functions",
        "slug": "functions",
        "lvl": 1,
        "i": 13,
        "seen": 0,
        "parents": [],
        "chunk": " Functions\n\n```js\ninterface Function <: Node {\n  id: Identifier | null;\n  params: [ Pattern ];\n  body: BlockStatement;\n  generator: boolean;\n  async: boolean;\n}\n```\n\nA function [declaration](#functiondeclaration) or [expression](#functionexpression).\n"
    },
    "Statements": {
        "content": "Statements",
        "slug": "statements",
        "lvl": 1,
        "i": 14,
        "seen": 0,
        "parents": [],
        "chunk": " Statements\n\n```js\ninterface Statement <: Node { }\n```\n\nAny statement.\n"
    },
    "ExpressionStatement": {
        "content": "ExpressionStatement",
        "slug": "expressionstatement",
        "lvl": 2,
        "i": 15,
        "seen": 0,
        "parents": [
            14
        ],
        "chunk": "# ExpressionStatement\n\n```js\ninterface ExpressionStatement <: Statement {\n  type: \"ExpressionStatement\";\n  expression: Expression;\n}\n```\n\nAn expression statement, i.e., a statement consisting of a single expression.\n"
    },
    "BlockStatement": {
        "content": "BlockStatement",
        "slug": "blockstatement",
        "lvl": 2,
        "i": 16,
        "seen": 0,
        "parents": [
            14
        ],
        "chunk": "# BlockStatement\n\n```js\ninterface BlockStatement <: Statement {\n  type: \"BlockStatement\";\n  body: [ Statement ];\n  directives: [ Directive ];\n}\n```\n\nA block statement, i.e., a sequence of statements surrounded by braces.\n"
    },
    "EmptyStatement": {
        "content": "EmptyStatement",
        "slug": "emptystatement",
        "lvl": 2,
        "i": 17,
        "seen": 0,
        "parents": [
            14
        ],
        "chunk": "# EmptyStatement\n\n```js\ninterface EmptyStatement <: Statement {\n  type: \"EmptyStatement\";\n}\n```\n\nAn empty statement, i.e., a solitary semicolon.\n"
    },
    "DebuggerStatement": {
        "content": "DebuggerStatement",
        "slug": "debuggerstatement",
        "lvl": 2,
        "i": 18,
        "seen": 0,
        "parents": [
            14
        ],
        "chunk": "# DebuggerStatement\n\n```js\ninterface DebuggerStatement <: Statement {\n  type: \"DebuggerStatement\";\n}\n```\n\nA `debugger` statement.\n"
    },
    "WithStatement": {
        "content": "WithStatement",
        "slug": "withstatement",
        "lvl": 2,
        "i": 19,
        "seen": 0,
        "parents": [
            14
        ],
        "chunk": "# WithStatement\n\n```js\ninterface WithStatement <: Statement {\n  type: \"WithStatement\";\n  object: Expression;\n  body: Statement;\n}\n```\n\nA `with` statement.\n"
    },
    "Control flow": {
        "content": "Control flow",
        "slug": "control-flow",
        "lvl": 2,
        "i": 20,
        "seen": 0,
        "parents": [
            14
        ],
        "chunk": "# Control flow\n"
    },
    "ReturnStatement": {
        "content": "ReturnStatement",
        "slug": "returnstatement",
        "lvl": 3,
        "i": 21,
        "seen": 0,
        "parents": [
            14,
            20
        ],
        "chunk": "## ReturnStatement\n\n```js\ninterface ReturnStatement <: Statement {\n  type: \"ReturnStatement\";\n  argument: Expression | null;\n}\n```\n\nA `return` statement.\n"
    },
    "LabeledStatement": {
        "content": "LabeledStatement",
        "slug": "labeledstatement",
        "lvl": 3,
        "i": 22,
        "seen": 0,
        "parents": [
            14,
            20
        ],
        "chunk": "## LabeledStatement\n\n```js\ninterface LabeledStatement <: Statement {\n  type: \"LabeledStatement\";\n  label: Identifier;\n  body: Statement;\n}\n```\n\nA labeled statement, i.e., a statement prefixed by a `break`/`continue` label.\n"
    },
    "BreakStatement": {
        "content": "BreakStatement",
        "slug": "breakstatement",
        "lvl": 3,
        "i": 23,
        "seen": 0,
        "parents": [
            14,
            20
        ],
        "chunk": "## BreakStatement\n\n```js\ninterface BreakStatement <: Statement {\n  type: \"BreakStatement\";\n  label: Identifier | null;\n}\n```\n\nA `break` statement.\n"
    },
    "ContinueStatement": {
        "content": "ContinueStatement",
        "slug": "continuestatement",
        "lvl": 3,
        "i": 24,
        "seen": 0,
        "parents": [
            14,
            20
        ],
        "chunk": "## ContinueStatement\n\n```js\ninterface ContinueStatement <: Statement {\n  type: \"ContinueStatement\";\n  label: Identifier | null;\n}\n```\n\nA `continue` statement.\n"
    },
    "Choice": {
        "content": "Choice",
        "slug": "choice",
        "lvl": 2,
        "i": 25,
        "seen": 0,
        "parents": [
            14
        ],
        "chunk": "# Choice\n"
    },
    "IfStatement": {
        "content": "IfStatement",
        "slug": "ifstatement",
        "lvl": 3,
        "i": 26,
        "seen": 0,
        "parents": [
            14,
            25
        ],
        "chunk": "## IfStatement\n\n```js\ninterface IfStatement <: Statement {\n  type: \"IfStatement\";\n  test: Expression;\n  consequent: Statement;\n  alternate: Statement | null;\n}\n```\n\nAn `if` statement.\n"
    },
    "SwitchStatement": {
        "content": "SwitchStatement",
        "slug": "switchstatement",
        "lvl": 3,
        "i": 27,
        "seen": 0,
        "parents": [
            14,
            25
        ],
        "chunk": "## SwitchStatement\n\n```js\ninterface SwitchStatement <: Statement {\n  type: \"SwitchStatement\";\n  discriminant: Expression;\n  cases: [ SwitchCase ];\n}\n```\n\nA `switch` statement.\n"
    },
    "SwitchCase": {
        "content": "SwitchCase",
        "slug": "switchcase",
        "lvl": 4,
        "i": 28,
        "seen": 0,
        "parents": [
            14,
            25,
            27
        ],
        "chunk": "### SwitchCase\n\n```js\ninterface SwitchCase <: Node {\n  type: \"SwitchCase\";\n  test: Expression | null;\n  consequent: [ Statement ];\n}\n```\n\nA `case` (if `test` is an `Expression`) or `default` (if `test === null`) clause in the body of a `switch` statement.\n"
    },
    "Exceptions": {
        "content": "Exceptions",
        "slug": "exceptions",
        "lvl": 2,
        "i": 29,
        "seen": 0,
        "parents": [
            14
        ],
        "chunk": "# Exceptions\n"
    },
    "ThrowStatement": {
        "content": "ThrowStatement",
        "slug": "throwstatement",
        "lvl": 3,
        "i": 30,
        "seen": 0,
        "parents": [
            14,
            29
        ],
        "chunk": "## ThrowStatement\n\n```js\ninterface ThrowStatement <: Statement {\n  type: \"ThrowStatement\";\n  argument: Expression;\n}\n```\n\nA `throw` statement.\n"
    },
    "TryStatement": {
        "content": "TryStatement",
        "slug": "trystatement",
        "lvl": 3,
        "i": 31,
        "seen": 0,
        "parents": [
            14,
            29
        ],
        "chunk": "## TryStatement\n\n```js\ninterface TryStatement <: Statement {\n  type: \"TryStatement\";\n  block: BlockStatement;\n  handler: CatchClause | null;\n  finalizer: BlockStatement | null;\n}\n```\n\nA `try` statement. If `handler` is `null` then `finalizer` must be a `BlockStatement`.\n"
    },
    "CatchClause": {
        "content": "CatchClause",
        "slug": "catchclause",
        "lvl": 4,
        "i": 32,
        "seen": 0,
        "parents": [
            14,
            29,
            31
        ],
        "chunk": "### CatchClause\n\n```js\ninterface CatchClause <: Node {\n  type: \"CatchClause\";\n  param?: Pattern;\n  body: BlockStatement;\n}\n```\n\nA `catch` clause following a `try` block.\n"
    },
    "Loops": {
        "content": "Loops",
        "slug": "loops",
        "lvl": 2,
        "i": 33,
        "seen": 0,
        "parents": [
            14
        ],
        "chunk": "# Loops\n"
    },
    "WhileStatement": {
        "content": "WhileStatement",
        "slug": "whilestatement",
        "lvl": 3,
        "i": 34,
        "seen": 0,
        "parents": [
            14,
            33
        ],
        "chunk": "## WhileStatement\n\n```js\ninterface WhileStatement <: Statement {\n  type: \"WhileStatement\";\n  test: Expression;\n  body: Statement;\n}\n```\n\nA `while` statement.\n"
    },
    "DoWhileStatement": {
        "content": "DoWhileStatement",
        "slug": "dowhilestatement",
        "lvl": 3,
        "i": 35,
        "seen": 0,
        "parents": [
            14,
            33
        ],
        "chunk": "## DoWhileStatement\n\n```js\ninterface DoWhileStatement <: Statement {\n  type: \"DoWhileStatement\";\n  body: Statement;\n  test: Expression;\n}\n```\n\nA `do`/`while` statement.\n"
    },
    "ForStatement": {
        "content": "ForStatement",
        "slug": "forstatement",
        "lvl": 3,
        "i": 36,
        "seen": 0,
        "parents": [
            14,
            33
        ],
        "chunk": "## ForStatement\n\n```js\ninterface ForStatement <: Statement {\n  type: \"ForStatement\";\n  init: VariableDeclaration | Expression | null;\n  test: Expression | null;\n  update: Expression | null;\n  body: Statement;\n}\n```\n\nA `for` statement.\n"
    },
    "ForInStatement": {
        "content": "ForInStatement",
        "slug": "forinstatement",
        "lvl": 3,
        "i": 37,
        "seen": 0,
        "parents": [
            14,
            33
        ],
        "chunk": "## ForInStatement\n\n```js\ninterface ForInStatement <: Statement {\n  type: \"ForInStatement\";\n  left: VariableDeclaration |  Expression;\n  right: Expression;\n  body: Statement;\n}\n```\n\nA `for`/`in` statement.\n"
    },
    "ForOfStatement": {
        "content": "ForOfStatement",
        "slug": "forofstatement",
        "lvl": 2,
        "i": 38,
        "seen": 0,
        "parents": [
            14
        ],
        "chunk": "# ForOfStatement\n\n```js\ninterface ForOfStatement <: ForInStatement {\n  type: \"ForOfStatement\";\n  await: boolean;\n}\n```\n"
    },
    "Declarations": {
        "content": "Declarations",
        "slug": "declarations",
        "lvl": 1,
        "i": 39,
        "seen": 0,
        "parents": [],
        "chunk": " Declarations\n\n```js\ninterface Declaration <: Statement { }\n```\n\nAny declaration node. Note that declarations are considered statements; this is because declarations can appear in any statement context.\n"
    },
    "FunctionDeclaration": {
        "content": "FunctionDeclaration",
        "slug": "functiondeclaration",
        "lvl": 2,
        "i": 40,
        "seen": 0,
        "parents": [
            39
        ],
        "chunk": "# FunctionDeclaration\n\n```js\ninterface FunctionDeclaration <: Function, Declaration {\n  type: \"FunctionDeclaration\";\n  id: Identifier;\n}\n```\n\nA function declaration. Note that unlike in the parent interface `Function`, the `id` cannot be `null`, except when this is the child of an `ExportDefaultDeclaration`.\n"
    },
    "VariableDeclaration": {
        "content": "VariableDeclaration",
        "slug": "variabledeclaration",
        "lvl": 2,
        "i": 41,
        "seen": 0,
        "parents": [
            39
        ],
        "chunk": "# VariableDeclaration\n\n```js\ninterface VariableDeclaration <: Declaration {\n  type: \"VariableDeclaration\";\n  declarations: [ VariableDeclarator ];\n  kind: \"var\" | \"let\" | \"const\";\n}\n```\n\nA variable declaration.\n"
    },
    "VariableDeclarator": {
        "content": "VariableDeclarator",
        "slug": "variabledeclarator",
        "lvl": 3,
        "i": 42,
        "seen": 0,
        "parents": [
            39,
            41
        ],
        "chunk": "## VariableDeclarator\n\n```js\ninterface VariableDeclarator <: Node {\n  type: \"VariableDeclarator\";\n  id: Pattern;\n  init: Expression | null;\n}\n```\n\nA variable declarator.\n"
    },
    "Misc": {
        "content": "Misc",
        "slug": "misc",
        "lvl": 1,
        "i": 43,
        "seen": 0,
        "parents": [],
        "chunk": " Misc\n"
    },
    "Decorator": {
        "content": "Decorator",
        "slug": "decorator",
        "lvl": 2,
        "i": 44,
        "seen": 0,
        "parents": [
            43
        ],
        "chunk": "# Decorator\n\n```js\ninterface Decorator <: Node {\n  type: \"Decorator\";\n  expression: Expression;\n}\n```\n"
    },
    "Directive": {
        "content": "Directive",
        "slug": "directive",
        "lvl": 2,
        "i": 45,
        "seen": 0,
        "parents": [
            43
        ],
        "chunk": "# Directive\n\n```js\ninterface Directive <: Node {\n  type: \"Directive\";\n  value: DirectiveLiteral;\n}\n```\n"
    },
    "DirectiveLiteral": {
        "content": "DirectiveLiteral",
        "slug": "directiveliteral",
        "lvl": 2,
        "i": 46,
        "seen": 0,
        "parents": [
            43
        ],
        "chunk": "# DirectiveLiteral\n\n```js\ninterface DirectiveLiteral <: StringLiteral {\n  type: \"DirectiveLiteral\";\n}\n```\n"
    },
    "InterpreterDirective": {
        "content": "InterpreterDirective",
        "slug": "interpreterdirective",
        "lvl": 2,
        "i": 47,
        "seen": 0,
        "parents": [
            43
        ],
        "chunk": "# InterpreterDirective\n\n```js\ninterface InterpreterDirective <: StringLiteral {\n  type: \"InterpreterDirective\";\n}\n```\n"
    },
    "Expressions": {
        "content": "Expressions",
        "slug": "expressions",
        "lvl": 1,
        "i": 48,
        "seen": 0,
        "parents": [],
        "chunk": " Expressions\n\n```js\ninterface Expression <: Node { }\n```\n\nAny expression node. Since the left-hand side of an assignment may be any expression in general, an expression can also be a pattern.\n"
    },
    "Super": {
        "content": "Super",
        "slug": "super",
        "lvl": 2,
        "i": 49,
        "seen": 0,
        "parents": [
            48
        ],
        "chunk": "# Super\n\n```js\ninterface Super <: Node {\n    type: \"Super\";\n}\n```\n\nA `super` pseudo-expression.\n"
    },
    "Import": {
        "content": "Import",
        "slug": "import",
        "lvl": 2,
        "i": 50,
        "seen": 0,
        "parents": [
            48
        ],
        "chunk": "# Import\n\n```js\ninterface Import <: Node {\n    type: \"Import\";\n}\n```\n\nA `import` pseudo-expression.\n"
    },
    "ThisExpression": {
        "content": "ThisExpression",
        "slug": "thisexpression",
        "lvl": 2,
        "i": 51,
        "seen": 0,
        "parents": [
            48
        ],
        "chunk": "# ThisExpression\n\n```js\ninterface ThisExpression <: Expression {\n  type: \"ThisExpression\";\n}\n```\n\nA `this` expression.\n"
    },
    "ArrowFunctionExpression": {
        "content": "ArrowFunctionExpression",
        "slug": "arrowfunctionexpression",
        "lvl": 2,
        "i": 52,
        "seen": 0,
        "parents": [
            48
        ],
        "chunk": "# ArrowFunctionExpression\n\n```js\ninterface ArrowFunctionExpression <: Function, Expression {\n  type: \"ArrowFunctionExpression\";\n  body: BlockStatement | Expression;\n}\n```\n\nA fat arrow function expression, e.g., `let foo = (bar) => { /* body */ }`.\n"
    },
    "YieldExpression": {
        "content": "YieldExpression",
        "slug": "yieldexpression",
        "lvl": 2,
        "i": 53,
        "seen": 0,
        "parents": [
            48
        ],
        "chunk": "# YieldExpression\n\n```js\ninterface YieldExpression <: Expression {\n  type: \"YieldExpression\";\n  argument: Expression | null;\n  delegate: boolean;\n}\n```\n\nA `yield` expression.\n"
    },
    "AwaitExpression": {
        "content": "AwaitExpression",
        "slug": "awaitexpression",
        "lvl": 2,
        "i": 54,
        "seen": 0,
        "parents": [
            48
        ],
        "chunk": "# AwaitExpression\n\n```js\ninterface AwaitExpression <: Expression {\n  type: \"AwaitExpression\";\n  argument: Expression | null;\n}\n```\n\nA `await` expression.\n"
    },
    "ArrayExpression": {
        "content": "ArrayExpression",
        "slug": "arrayexpression",
        "lvl": 2,
        "i": 55,
        "seen": 0,
        "parents": [
            48
        ],
        "chunk": "# ArrayExpression\n\n```js\ninterface ArrayExpression <: Expression {\n  type: \"ArrayExpression\";\n  elements: [ Expression | SpreadElement | null ];\n}\n```\n\nAn array expression.\n"
    },
    "ObjectExpression": {
        "content": "ObjectExpression",
        "slug": "objectexpression",
        "lvl": 2,
        "i": 56,
        "seen": 0,
        "parents": [
            48
        ],
        "chunk": "# ObjectExpression\n\n```js\ninterface ObjectExpression <: Expression {\n  type: \"ObjectExpression\";\n  properties: [ ObjectProperty | ObjectMethod | SpreadElement ];\n}\n```\n\nAn object expression.\n"
    },
    "ObjectMember": {
        "content": "ObjectMember",
        "slug": "objectmember",
        "lvl": 3,
        "i": 57,
        "seen": 0,
        "parents": [
            48,
            56
        ],
        "chunk": "## ObjectMember\n\n```js\ninterface ObjectMember <: Node {\n  key: Expression;\n  computed: boolean;\n  decorators: [ Decorator ];\n}\n```\n"
    },
    "ObjectProperty": {
        "content": "ObjectProperty",
        "slug": "objectproperty",
        "lvl": 4,
        "i": 58,
        "seen": 0,
        "parents": [
            48,
            56,
            57
        ],
        "chunk": "### ObjectProperty\n\n```js\ninterface ObjectProperty <: ObjectMember {\n  type: \"ObjectProperty\";\n  shorthand: boolean;\n  value: Expression;\n}\n```\n"
    },
    "ObjectMethod": {
        "content": "ObjectMethod",
        "slug": "objectmethod",
        "lvl": 4,
        "i": 59,
        "seen": 0,
        "parents": [
            48,
            56,
            57
        ],
        "chunk": "### ObjectMethod\n\n```js\ninterface ObjectMethod <: ObjectMember, Function {\n  type: \"ObjectMethod\";\n  kind: \"get\" | \"set\" | \"method\";\n}\n```\n"
    },
    "RecordExpression": {
        "content": "RecordExpression",
        "slug": "recordexpression",
        "lvl": 2,
        "i": 60,
        "seen": 0,
        "parents": [
            48
        ],
        "chunk": "# RecordExpression\n\n```js\ninterface RecordExpression <: Expression {\n  type: \"RecordExpression\";\n  properties: [ ObjectProperty | ObjectMethod | SpreadElement ];\n}\n```\n"
    },
    "TupleExpression": {
        "content": "TupleExpression",
        "slug": "tupleexpression",
        "lvl": 2,
        "i": 61,
        "seen": 0,
        "parents": [
            48
        ],
        "chunk": "# TupleExpression\n\n```js\ninterface TupleExpression <: Expression {\n  type: \"TupleExpression\";\n  elements: [ Expression | SpreadElement | null ];\n}\n```\n"
    },
    "FunctionExpression": {
        "content": "FunctionExpression",
        "slug": "functionexpression",
        "lvl": 2,
        "i": 62,
        "seen": 0,
        "parents": [
            48
        ],
        "chunk": "# FunctionExpression\n\n```js\ninterface FunctionExpression <: Function, Expression {\n  type: \"FunctionExpression\";\n}\n```\n\nA `function` expression.\n"
    },
    "Unary operations": {
        "content": "Unary operations",
        "slug": "unary-operations",
        "lvl": 2,
        "i": 63,
        "seen": 0,
        "parents": [
            48
        ],
        "chunk": "# Unary operations\n"
    },
    "UnaryExpression": {
        "content": "UnaryExpression",
        "slug": "unaryexpression",
        "lvl": 3,
        "i": 64,
        "seen": 0,
        "parents": [
            48,
            63
        ],
        "chunk": "## UnaryExpression\n\n```js\ninterface UnaryExpression <: Expression {\n  type: \"UnaryExpression\";\n  operator: UnaryOperator;\n  prefix: boolean;\n  argument: Expression;\n}\n```\n\nA unary operator expression.\n"
    },
    "UnaryOperator": {
        "content": "UnaryOperator",
        "slug": "unaryoperator",
        "lvl": 4,
        "i": 65,
        "seen": 0,
        "parents": [
            48,
            63,
            64
        ],
        "chunk": "### UnaryOperator\n\n```js\nenum UnaryOperator {\n  \"-\" | \"+\" | \"!\" | \"~\" | \"typeof\" | \"void\" | \"delete\" | \"throw\"\n}\n```\n\nA unary operator token.\n"
    },
    "UpdateExpression": {
        "content": "UpdateExpression",
        "slug": "updateexpression",
        "lvl": 3,
        "i": 66,
        "seen": 0,
        "parents": [
            48,
            63
        ],
        "chunk": "## UpdateExpression\n\n```js\ninterface UpdateExpression <: Expression {\n  type: \"UpdateExpression\";\n  operator: UpdateOperator;\n  argument: Expression;\n  prefix: boolean;\n}\n```\n\nAn update (increment or decrement) operator expression.\n"
    },
    "UpdateOperator": {
        "content": "UpdateOperator",
        "slug": "updateoperator",
        "lvl": 4,
        "i": 67,
        "seen": 0,
        "parents": [
            48,
            63,
            66
        ],
        "chunk": "### UpdateOperator\n\n```js\nenum UpdateOperator {\n  \"++\" | \"--\"\n}\n```\n\nAn update (increment or decrement) operator token.\n"
    },
    "Binary operations": {
        "content": "Binary operations",
        "slug": "binary-operations",
        "lvl": 2,
        "i": 68,
        "seen": 0,
        "parents": [
            48
        ],
        "chunk": "# Binary operations\n"
    },
    "BinaryExpression": {
        "content": "BinaryExpression",
        "slug": "binaryexpression",
        "lvl": 3,
        "i": 69,
        "seen": 0,
        "parents": [
            48,
            68
        ],
        "chunk": "## BinaryExpression\n\n```js\ninterface BinaryExpression <: Expression {\n  type: \"BinaryExpression\";\n  operator: BinaryOperator;\n  left: Expression | PrivateName;\n  right: Expression;\n}\n```\n\nA binary operator expression. When `operator` is `in`, the `left` can be a `PrivateName`.\n"
    },
    "BinaryOperator": {
        "content": "BinaryOperator",
        "slug": "binaryoperator",
        "lvl": 4,
        "i": 70,
        "seen": 0,
        "parents": [
            48,
            68,
            69
        ],
        "chunk": "### BinaryOperator\n\n```js\nenum BinaryOperator {\n  \"==\" | \"!=\" | \"===\" | \"!==\"\n     | \"<\" | \"<=\" | \">\" | \">=\"\n     | \"<<\" | \">>\" | \">>>\"\n     | \"+\" | \"-\" | \"*\" | \"/\" | \"%\"\n     | \"**\" | \"|\" | \"^\" | \"&\" | \"in\"\n     | \"instanceof\"\n     | \"|>\"\n}\n```\n\nA binary operator token.\n"
    },
    "AssignmentExpression": {
        "content": "AssignmentExpression",
        "slug": "assignmentexpression",
        "lvl": 3,
        "i": 71,
        "seen": 0,
        "parents": [
            48,
            68
        ],
        "chunk": "## AssignmentExpression\n\n```js\ninterface AssignmentExpression <: Expression {\n  type: \"AssignmentExpression\";\n  operator: AssignmentOperator;\n  left: Pattern | Expression;\n  right: Expression;\n}\n```\n\nAn assignment operator expression. It has short-circuiting behaviour if the `operator` is one of `\"||=\"`, `\"&&=\"`, and `\"??=\"`.\n"
    },
    "AssignmentOperator": {
        "content": "AssignmentOperator",
        "slug": "assignmentoperator",
        "lvl": 4,
        "i": 72,
        "seen": 0,
        "parents": [
            48,
            68,
            71
        ],
        "chunk": "### AssignmentOperator\n\n```js\nenum AssignmentOperator {\n  \"=\" | \"+=\" | \"-=\" | \"*=\" | \"/=\" | \"%=\" | \"**=\"\n    | \"<<=\" | \">>=\" | \">>>=\"\n    | \"|=\" | \"^=\" | \"&=\"\n    | \"||=\" | \"&&=\" | \"??=\"\n}\n```\n\nAn assignment operator token.\n"
    },
    "LogicalExpression": {
        "content": "LogicalExpression",
        "slug": "logicalexpression",
        "lvl": 3,
        "i": 73,
        "seen": 0,
        "parents": [
            48,
            68
        ],
        "chunk": "## LogicalExpression\n\n```js\ninterface LogicalExpression <: Expression {\n  type: \"LogicalExpression\";\n  operator: LogicalOperator;\n  left: Expression;\n  right: Expression;\n}\n```\n\nA logical operator expression.\n"
    },
    "LogicalOperator": {
        "content": "LogicalOperator",
        "slug": "logicaloperator",
        "lvl": 4,
        "i": 74,
        "seen": 0,
        "parents": [
            48,
            68,
            73
        ],
        "chunk": "### LogicalOperator\n\n```js\nenum LogicalOperator {\n  \"||\" | \"&&\" | \"??\"\n}\n```\n\nA logical operator token.\n"
    },
    "SpreadElement": {
        "content": "SpreadElement",
        "slug": "spreadelement",
        "lvl": 3,
        "i": 75,
        "seen": 0,
        "parents": [
            48,
            68
        ],
        "chunk": "## SpreadElement\n\n```js\ninterface SpreadElement <: Node {\n  type: \"SpreadElement\";\n  argument: Expression;\n}\n```\n"
    },
    "ArgumentPlaceholder": {
        "content": "ArgumentPlaceholder",
        "slug": "argumentplaceholder",
        "lvl": 3,
        "i": 76,
        "seen": 0,
        "parents": [
            48,
            68
        ],
        "chunk": "## ArgumentPlaceholder\n\n```js\ninterface ArgumentPlaceholder <: Node {\n    type: \"ArgumentPlaceholder\";\n}\n```\n"
    },
    "MemberExpression": {
        "content": "MemberExpression",
        "slug": "memberexpression",
        "lvl": 3,
        "i": 77,
        "seen": 0,
        "parents": [
            48,
            68
        ],
        "chunk": "## MemberExpression\n\n```js\ninterface MemberExpression <: Expression, Pattern {\n  type: \"MemberExpression\";\n  object: Expression | Super;\n  property: Expression | PrivateName;\n  computed: boolean;\n}\n```\n\nA member expression. If `computed` is `true`, the node corresponds to a computed (`a[b]`) member expression and `property` is an `Expression`. If `computed` is `false`, the node corresponds to a static (`a.b`) member expression and `property` is an `Identifier` or a `PrivateName`.\n"
    },
    "OptionalMemberExpression": {
        "content": "OptionalMemberExpression",
        "slug": "optionalmemberexpression",
        "lvl": 3,
        "i": 78,
        "seen": 0,
        "parents": [
            48,
            68
        ],
        "chunk": "## OptionalMemberExpression\n\n```js\ninterface OptionalMemberExpression <: Expression {\n  type: \"OptionalMemberExpression\";\n  object: Expression;\n  property: Expression | PrivateName;\n  computed: boolean;\n  optional: boolean;\n}\n```\n\nAn optional member expression is a part of the optional chain. When `optional` is `true`, it is the starting element of the optional chain. i.e. In `a?.b.c`, `?.b` is an optional member expression with `optional: true`, `.c` is an optional member expression. See this [gist](https://gist.github.com/JLHwung/567fb29fa2b82bbe164ad9067ff3290f) for more AST examples.\n"
    },
    "BindExpression": {
        "content": "BindExpression",
        "slug": "bindexpression",
        "lvl": 3,
        "i": 79,
        "seen": 0,
        "parents": [
            48,
            68
        ],
        "chunk": "## BindExpression\n\n```js\ninterface BindExpression <: Expression {\n    type: \"BindExpression\";\n    object: Expression | null;\n    callee: Expression;\n}\n```\n\nIf `object` is `null`, then `callee` should be a `MemberExpression`.\n"
    },
    "Pipeline": {
        "content": "Pipeline",
        "slug": "pipeline",
        "lvl": 3,
        "i": 80,
        "seen": 0,
        "parents": [
            48,
            68
        ],
        "chunk": "## Pipeline\n\nThese nodes are used by the Smart Pipeline to determine the type of the expression in a Pipeline Operator Expression. The F# Pipeline uses simple `BinaryExpression`s.\n"
    },
    "PipelineBody": {
        "content": "PipelineBody",
        "slug": "pipelinebody",
        "lvl": 4,
        "i": 81,
        "seen": 0,
        "parents": [
            48,
            68,
            80
        ],
        "chunk": "### PipelineBody\n\n```js\ninterface PipelineBody <: NodeBase {\n    type: \"PipelineBody\";\n}\n```\n"
    },
    "PipelineBareFunctionBody": {
        "content": "PipelineBareFunctionBody",
        "slug": "pipelinebarefunctionbody",
        "lvl": 4,
        "i": 82,
        "seen": 0,
        "parents": [
            48,
            68,
            80
        ],
        "chunk": "### PipelineBareFunctionBody\n\n```js\ninterface PipelineBody <: NodeBase {\n    type: \"PipelineBareFunctionBody\";\n    callee: Expression;\n}\n```\n"
    },
    "PipelineBareConstructorBody": {
        "content": "PipelineBareConstructorBody",
        "slug": "pipelinebareconstructorbody",
        "lvl": 4,
        "i": 83,
        "seen": 0,
        "parents": [
            48,
            68,
            80
        ],
        "chunk": "### PipelineBareConstructorBody\n\n```js\ninterface PipelineBareConstructorBody <: NodeBase {\n    type: \"PipelineBareConstructorBody\";\n    callee: Expression;\n}\n```\n"
    },
    "PipelineBareAwaitedFunctionBody": {
        "content": "PipelineBareAwaitedFunctionBody",
        "slug": "pipelinebareawaitedfunctionbody",
        "lvl": 4,
        "i": 84,
        "seen": 0,
        "parents": [
            48,
            68,
            80
        ],
        "chunk": "### PipelineBareAwaitedFunctionBody\n\n```js\ninterface PipelineBareConstructorBody <: NodeBase {\n    type: \"PipelineTopicBody\";\n    expression: Expression;\n}\n```\n"
    },
    "PipelineTopicBody": {
        "content": "PipelineTopicBody",
        "slug": "pipelinetopicbody",
        "lvl": 4,
        "i": 85,
        "seen": 0,
        "parents": [
            48,
            68,
            80
        ],
        "chunk": "### PipelineTopicBody\n\n```js\ninterface PipelineBareConstructorBody <: NodeBase {\n    type: \"PipelineBareAwaitedFunctionBody\";\n    callee: Expression;\n}\n```\n"
    },
    "ConditionalExpression": {
        "content": "ConditionalExpression",
        "slug": "conditionalexpression",
        "lvl": 2,
        "i": 86,
        "seen": 0,
        "parents": [
            48
        ],
        "chunk": "# ConditionalExpression\n\n```js\ninterface ConditionalExpression <: Expression {\n  type: \"ConditionalExpression\";\n  test: Expression;\n  alternate: Expression;\n  consequent: Expression;\n}\n```\n\nA conditional expression, i.e., a ternary `?`/`:` expression.\n"
    },
    "CallExpression": {
        "content": "CallExpression",
        "slug": "callexpression",
        "lvl": 2,
        "i": 87,
        "seen": 0,
        "parents": [
            48
        ],
        "chunk": "# CallExpression\n\n```js\ninterface CallExpression <: Expression {\n  type: \"CallExpression\";\n  callee: Expression | Super | Import;\n  arguments: [ Expression | SpreadElement ];\n}\n```\n\nA function or method call expression. When the `callee` is `Import`, the `arguments` must have only one `Expression` element.\n"
    },
    "OptionalCallExpression": {
        "content": "OptionalCallExpression",
        "slug": "optionalcallexpression",
        "lvl": 2,
        "i": 88,
        "seen": 0,
        "parents": [
            48
        ],
        "chunk": "# OptionalCallExpression\n\n```js\ninterface OptionalCallExpression <: Expression {\n  type: \"OptionalCallExpression\";\n  callee: Expression;\n  arguments: [ Expression | SpreadElement ];\n  optional: boolean;\n}\n```\n\nAn optional call expression is a part of the optional chain. When `optional` is `true`, it is the starting element of the optional chain. i.e. In `f?.()()`, `?.()` is an optional call expression with `optional: true`, `()` is an optional call expression with `optional: false`. See this [gist](https://gist.github.com/JLHwung/567fb29fa2b82bbe164ad9067ff3290f) for more AST examples.\n"
    },
    "NewExpression": {
        "content": "NewExpression",
        "slug": "newexpression",
        "lvl": 2,
        "i": 89,
        "seen": 0,
        "parents": [
            48
        ],
        "chunk": "# NewExpression\n\n```js\ninterface NewExpression <: CallExpression {\n  type: \"NewExpression\";\n}\n```\n\nA `new` expression.\n"
    },
    "SequenceExpression": {
        "content": "SequenceExpression",
        "slug": "sequenceexpression",
        "lvl": 2,
        "i": 90,
        "seen": 0,
        "parents": [
            48
        ],
        "chunk": "# SequenceExpression\n\n```js\ninterface SequenceExpression <: Expression {\n  type: \"SequenceExpression\";\n  expressions: [ Expression ];\n}\n```\n\nA sequence expression, i.e., a comma-separated sequence of expressions.\n"
    },
    "ParenthesizedExpression": {
        "content": "ParenthesizedExpression",
        "slug": "parenthesizedexpression",
        "lvl": 2,
        "i": 91,
        "seen": 0,
        "parents": [
            48
        ],
        "chunk": "# ParenthesizedExpression\n\n```js\ninterface ParenthesizedExpression <: Expression {\n    type \"ParenthesizedExpression\";\n    expression: Expression;\n}\n```\n\nAn expression wrapped by parentheses. By default `@babel/parser` does not create this node, unless the `createParenthesizedExpressions: true` option is passed.\n"
    },
    "DoExpression": {
        "content": "DoExpression",
        "slug": "doexpression",
        "lvl": 2,
        "i": 92,
        "seen": 0,
        "parents": [
            48
        ],
        "chunk": "# DoExpression\n\n```js\ninterface DoExpression <: Expression {\n  type: \"DoExpression\";\n  body: BlockStatement\n}\n```\n"
    },
    "Template Literals": {
        "content": "Template Literals",
        "slug": "template-literals",
        "lvl": 1,
        "i": 93,
        "seen": 0,
        "parents": [],
        "chunk": " Template Literals\n"
    },
    "TemplateLiteral": {
        "content": "TemplateLiteral",
        "slug": "templateliteral",
        "lvl": 2,
        "i": 94,
        "seen": 0,
        "parents": [
            93
        ],
        "chunk": "# TemplateLiteral\n\n```js\ninterface TemplateLiteral <: Expression {\n  type: \"TemplateLiteral\";\n  quasis: [ TemplateElement ];\n  expressions: [ Expression ];\n}\n```\n"
    },
    "TaggedTemplateExpression": {
        "content": "TaggedTemplateExpression",
        "slug": "taggedtemplateexpression",
        "lvl": 2,
        "i": 95,
        "seen": 0,
        "parents": [
            93
        ],
        "chunk": "# TaggedTemplateExpression\n\n```js\ninterface TaggedTemplateExpression <: Expression {\n  type: \"TaggedTemplateExpression\";\n  tag: Expression;\n  quasi: TemplateLiteral;\n}\n```\n"
    },
    "TemplateElement": {
        "content": "TemplateElement",
        "slug": "templateelement",
        "lvl": 2,
        "i": 96,
        "seen": 0,
        "parents": [
            93
        ],
        "chunk": "# TemplateElement\n\n```js\ninterface TemplateElement <: Node {\n  type: \"TemplateElement\";\n  tail: boolean;\n  value: {\n    cooked: string | null;\n    raw: string;\n  };\n}\n```\n"
    },
    "Patterns": {
        "content": "Patterns",
        "slug": "patterns",
        "lvl": 1,
        "i": 97,
        "seen": 0,
        "parents": [],
        "chunk": " Patterns\n\n```js\ninterface Pattern <: Node { }\n```\n"
    },
    "ObjectPattern": {
        "content": "ObjectPattern",
        "slug": "objectpattern",
        "lvl": 2,
        "i": 98,
        "seen": 0,
        "parents": [
            97
        ],
        "chunk": "# ObjectPattern\n\n```js\ninterface AssignmentProperty <: ObjectProperty {\n  value: Pattern;\n}\n\ninterface ObjectPattern <: Pattern {\n  type: \"ObjectPattern\";\n  properties: [ AssignmentProperty | RestElement ];\n}\n```\n"
    },
    "ArrayPattern": {
        "content": "ArrayPattern",
        "slug": "arraypattern",
        "lvl": 2,
        "i": 99,
        "seen": 0,
        "parents": [
            97
        ],
        "chunk": "# ArrayPattern\n\n```js\ninterface ArrayPattern <: Pattern {\n  type: \"ArrayPattern\";\n  elements: [ Pattern | null ];\n}\n```\n"
    },
    "RestElement": {
        "content": "RestElement",
        "slug": "restelement",
        "lvl": 2,
        "i": 100,
        "seen": 0,
        "parents": [
            97
        ],
        "chunk": "# RestElement\n\n```js\ninterface RestElement <: Pattern {\n  type: \"RestElement\";\n  argument: Pattern;\n}\n```\n"
    },
    "AssignmentPattern": {
        "content": "AssignmentPattern",
        "slug": "assignmentpattern",
        "lvl": 2,
        "i": 101,
        "seen": 0,
        "parents": [
            97
        ],
        "chunk": "# AssignmentPattern\n\n```js\ninterface AssignmentPattern <: Pattern {\n  type: \"AssignmentPattern\";\n  left: Pattern;\n  right: Expression;\n}\n```\n"
    },
    "Classes": {
        "content": "Classes",
        "slug": "classes",
        "lvl": 1,
        "i": 102,
        "seen": 0,
        "parents": [],
        "chunk": " Classes\n\n```js\ninterface Class <: Node {\n  id: Identifier | null;\n  superClass: Expression | null;\n  body: ClassBody;\n  decorators: [ Decorator ];\n}\n```\n"
    },
    "ClassBody": {
        "content": "ClassBody",
        "slug": "classbody",
        "lvl": 2,
        "i": 103,
        "seen": 0,
        "parents": [
            102
        ],
        "chunk": "# ClassBody\n\n```js\ninterface ClassBody <: Node {\n  type: \"ClassBody\";\n  body: [ ClassMethod | ClassPrivateMethod | ClassProperty | ClassPrivateProperty ];\n}\n```\n"
    },
    "ClassMethod": {
        "content": "ClassMethod",
        "slug": "classmethod",
        "lvl": 2,
        "i": 104,
        "seen": 0,
        "parents": [
            102
        ],
        "chunk": "# ClassMethod\n\n```js\ninterface ClassMethod <: Function {\n  type: \"ClassMethod\";\n  key: Expression;\n  kind: \"constructor\" | \"method\" | \"get\" | \"set\";\n  computed: boolean;\n  static: boolean;\n  decorators: [ Decorator ];\n}\n```\n"
    },
    "ClassPrivateMethod": {
        "content": "ClassPrivateMethod",
        "slug": "classprivatemethod",
        "lvl": 2,
        "i": 105,
        "seen": 0,
        "parents": [
            102
        ],
        "chunk": "# ClassPrivateMethod\n\n```js\ninterface ClassPrivateMethod <: Function {\n  type: \"ClassPrivateMethod\";\n  key: PrivateName;\n  kind: \"method\" | \"get\" | \"set\";\n  static: boolean;\n  decorators: [ Decorator ];\n}\n```\n"
    },
    "ClassProperty": {
        "content": "ClassProperty",
        "slug": "classproperty",
        "lvl": 2,
        "i": 106,
        "seen": 0,
        "parents": [
            102
        ],
        "chunk": "# ClassProperty\n\n```js\ninterface ClassProperty <: Node {\n  type: \"ClassProperty\";\n  key: Expression;\n  value: Expression;\n  static: boolean;\n  computed: boolean;\n}\n```\n"
    },
    "ClassPrivateProperty": {
        "content": "ClassPrivateProperty",
        "slug": "classprivateproperty",
        "lvl": 2,
        "i": 107,
        "seen": 0,
        "parents": [
            102
        ],
        "chunk": "# ClassPrivateProperty\n\n```js\ninterface ClassPrivateProperty <: Node {\n  type: \"ClassPrivateProperty\";\n  key: PrivateName;\n  value: Expression;\n  static: boolean;\n}\n```\n"
    },
    "ClassDeclaration": {
        "content": "ClassDeclaration",
        "slug": "classdeclaration",
        "lvl": 2,
        "i": 108,
        "seen": 0,
        "parents": [
            102
        ],
        "chunk": "# ClassDeclaration\n\n```js\ninterface ClassDeclaration <: Class, Declaration {\n  type: \"ClassDeclaration\";\n  id: Identifier;\n}\n```\n"
    },
    "ClassExpression": {
        "content": "ClassExpression",
        "slug": "classexpression",
        "lvl": 2,
        "i": 109,
        "seen": 0,
        "parents": [
            102
        ],
        "chunk": "# ClassExpression\n\n```js\ninterface ClassExpression <: Class, Expression {\n  type: \"ClassExpression\";\n}\n```\n"
    },
    "MetaProperty": {
        "content": "MetaProperty",
        "slug": "metaproperty",
        "lvl": 2,
        "i": 110,
        "seen": 0,
        "parents": [
            102
        ],
        "chunk": "# MetaProperty\n\n```js\ninterface MetaProperty <: Expression {\n  type: \"MetaProperty\";\n  meta: Identifier;\n  property: Identifier;\n}\n```\n"
    },
    "Modules": {
        "content": "Modules",
        "slug": "modules",
        "lvl": 1,
        "i": 111,
        "seen": 0,
        "parents": [],
        "chunk": " Modules\n"
    },
    "ModuleDeclaration": {
        "content": "ModuleDeclaration",
        "slug": "moduledeclaration",
        "lvl": 2,
        "i": 112,
        "seen": 0,
        "parents": [
            111
        ],
        "chunk": "# ModuleDeclaration\n\n```js\ninterface ModuleDeclaration <: Node { }\n```\n\nA module `import` or `export` declaration.\n"
    },
    "ModuleSpecifier": {
        "content": "ModuleSpecifier",
        "slug": "modulespecifier",
        "lvl": 2,
        "i": 113,
        "seen": 0,
        "parents": [
            111
        ],
        "chunk": "# ModuleSpecifier\n\n```js\ninterface ModuleSpecifier <: Node {\n  local: Identifier;\n}\n```\n\nA specifier in an import or export declaration.\n"
    },
    "Imports": {
        "content": "Imports",
        "slug": "imports",
        "lvl": 2,
        "i": 114,
        "seen": 0,
        "parents": [
            111
        ],
        "chunk": "# Imports\n"
    },
    "ImportDeclaration": {
        "content": "ImportDeclaration",
        "slug": "importdeclaration",
        "lvl": 3,
        "i": 115,
        "seen": 0,
        "parents": [
            111,
            114
        ],
        "chunk": "## ImportDeclaration\n\n```js\ninterface ImportDeclaration <: ModuleDeclaration {\n  type: \"ImportDeclaration\";\n  importKind: null | \"type\" | \"typeof\" | \"value\";\n  specifiers: [ ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier ];\n  source: Literal;\n  attributes?: [ ImportAttribute ];\n}\n```\n\nAn import declaration, e.g., `import foo from \"mod\";`.\n\n> importKind is only set when `flow` plugin enabled in babel-parser\n"
    },
    "ImportSpecifier": {
        "content": "ImportSpecifier",
        "slug": "importspecifier",
        "lvl": 3,
        "i": 116,
        "seen": 0,
        "parents": [
            111,
            114
        ],
        "chunk": "## ImportSpecifier\n\n```js\ninterface ImportSpecifier <: ModuleSpecifier {\n  type: \"ImportSpecifier\";\n  imported: Identifier;\n}\n```\n\nAn imported variable binding, e.g., `{foo}` in `import {foo} from \"mod\"` or `{foo as bar}` in `import {foo as bar} from \"mod\"`. The `imported` field refers to the name of the export imported from the module. The `local` field refers to the binding imported into the local module scope. If it is a basic named import, such as in `import {foo} from \"mod\"`, both `imported` and `local` are equivalent `Identifier` nodes; in this case an `Identifier` node representing `foo`. If it is an aliased import, such as in `import {foo as bar} from \"mod\"`, the `imported` field is an `Identifier` node representing `foo`, and the `local` field is an `Identifier` node representing `bar`.\n"
    },
    "ImportDefaultSpecifier": {
        "content": "ImportDefaultSpecifier",
        "slug": "importdefaultspecifier",
        "lvl": 3,
        "i": 117,
        "seen": 0,
        "parents": [
            111,
            114
        ],
        "chunk": "## ImportDefaultSpecifier\n\n```js\ninterface ImportDefaultSpecifier <: ModuleSpecifier {\n  type: \"ImportDefaultSpecifier\";\n}\n```\n\nA default import specifier, e.g., `foo` in `import foo from \"mod.js\"`.\n"
    },
    "ImportNamespaceSpecifier": {
        "content": "ImportNamespaceSpecifier",
        "slug": "importnamespacespecifier",
        "lvl": 3,
        "i": 118,
        "seen": 0,
        "parents": [
            111,
            114
        ],
        "chunk": "## ImportNamespaceSpecifier\n\n```js\ninterface ImportNamespaceSpecifier <: ModuleSpecifier {\n  type: \"ImportNamespaceSpecifier\";\n}\n```\n\nA namespace import specifier, e.g., `* as foo` in `import * as foo from \"mod.js\"`.\n"
    },
    "ImportAttribute": {
        "content": "ImportAttribute",
        "slug": "importattribute",
        "lvl": 3,
        "i": 119,
        "seen": 0,
        "parents": [
            111,
            114
        ],
        "chunk": "## ImportAttribute\n\n```js\ninterface ImportAttribute <: Node {\n  type: \"ImportAttribute\";\n  key: Identifier;\n  value: StringLiteral;\n}\n```\n\nAn attribute specified on the ImportDeclaration.\n"
    },
    "Exports": {
        "content": "Exports",
        "slug": "exports",
        "lvl": 2,
        "i": 120,
        "seen": 0,
        "parents": [
            111
        ],
        "chunk": "# Exports\n"
    },
    "ExportNamedDeclaration": {
        "content": "ExportNamedDeclaration",
        "slug": "exportnameddeclaration",
        "lvl": 3,
        "i": 121,
        "seen": 0,
        "parents": [
            111,
            120
        ],
        "chunk": "## ExportNamedDeclaration\n\n```js\ninterface ExportNamedDeclaration <: ModuleDeclaration {\n  type: \"ExportNamedDeclaration\";\n  declaration: Declaration | null;\n  specifiers: [ ExportSpecifier ];\n  source: Literal | null;\n}\n```\n\nAn export named declaration, e.g., `export {foo, bar};`, `export {foo} from \"mod\";`, `export var foo = 1;` or `export * as foo from \"bar\";`.\n\n_Note: Having `declaration` populated with non-empty `specifiers` or non-null `source` results in an invalid state._\n"
    },
    "ExportSpecifier": {
        "content": "ExportSpecifier",
        "slug": "exportspecifier",
        "lvl": 3,
        "i": 122,
        "seen": 0,
        "parents": [
            111,
            120
        ],
        "chunk": "## ExportSpecifier\n\n```js\ninterface ExportSpecifier <: ModuleSpecifier {\n  type: \"ExportSpecifier\";\n  exported: Identifier;\n  local?: Identifier;\n}\n```\n\nAn exported variable binding, e.g., `{foo}` in `export {foo}` or `{bar as foo}` in `export {bar as foo}`. The `exported` field refers to the name exported in the module. The `local` field refers to the binding into the local module scope. If it is a basic named export, such as in `export {foo}`, both `exported` and `local` are equivalent `Identifier` nodes; in this case an `Identifier` node representing `foo`. If it is an aliased export, such as in `export {bar as foo}`, the `exported` field is an `Identifier` node representing `foo`, and the `local` field is an `Identifier` node representing `bar`.\n"
    },
    "ExportDefaultDeclaration": {
        "content": "ExportDefaultDeclaration",
        "slug": "exportdefaultdeclaration",
        "lvl": 3,
        "i": 123,
        "seen": 0,
        "parents": [
            111,
            120
        ],
        "chunk": "## ExportDefaultDeclaration\n\n```js\ninterface OptFunctionDeclaration <: FunctionDeclaration {\n  id: Identifier | null;\n}\n\ninterface OptClassDeclaration <: ClassDeclaration {\n  id: Identifier | null;\n}\n\ninterface ExportDefaultDeclaration <: ModuleDeclaration {\n  type: \"ExportDefaultDeclaration\";\n  declaration: OptFunctionDeclaration | OptClassDeclaration | Expression;\n}\n```\n\nAn export default declaration, e.g., `export default function () {};` or `export default 1;`.\n"
    },
    "ExportAllDeclaration": {
        "content": "ExportAllDeclaration",
        "slug": "exportalldeclaration",
        "lvl": 3,
        "i": 124,
        "seen": 0,
        "parents": [
            111,
            120
        ],
        "chunk": "## ExportAllDeclaration\n\n```js\ninterface ExportAllDeclaration <: ModuleDeclaration {\n  type: \"ExportAllDeclaration\";\n  source: Literal;\n}\n```\n\nAn export batch declaration, e.g., `export * from \"mod\";`.\n"
    }
}